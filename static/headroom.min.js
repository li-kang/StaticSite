/*!
 * headroom.js v0.10.3 - Give your page some headroom. Hide your header until you need it
 * Copyright (c) 2019 Nick Williams - http://wicky.nillia.ms/headroom.js
 * License: MIT
 */

!(function (t, n) { typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = n() : typeof define === 'function' && define.amd ? define(n) : (t = t || self).Headroom = n() }(this, function () { 'use strict'; function t () { return typeof window !== 'undefined' } function d (t) { return (function (t) { return t && t.document && (function (t) { return t.nodeType === 9 }(t.document)) }(t)) ? (function (t) { const n = t.document; const o = n.body; const e = n.documentElement; return { scrollHeight () { return Math.max(o.scrollHeight, e.scrollHeight, o.offsetHeight, e.offsetHeight, o.clientHeight, e.clientHeight) }, height () { return t.innerHeight || e.clientHeight || o.clientHeight }, scrollY () { return void 0 !== t.pageYOffset ? t.pageYOffset : (e || o.parentNode || o).scrollTop } } }(t)) : (function (t) { return { scrollHeight () { return Math.max(t.scrollHeight, t.offsetHeight, t.clientHeight) }, height () { return Math.max(t.offsetHeight, t.clientHeight) }, scrollY () { return t.scrollTop } } }(t)) } function n (t, e, s) { let n; const o = (function () { let n = !1; try { const t = { get passive () { n = !0 } }; window.addEventListener('test', t, t), window.removeEventListener('test', t, t) } catch (t) { n = !1 } return n }()); let i = !1; const r = d(t); let a = r.scrollY(); const c = {}; function l () { const t = Math.round(r.scrollY()); const n = r.height(); const o = r.scrollHeight(); c.scrollY = t, c.lastScrollY = a, c.direction = a < t ? 'down' : 'up', c.distance = Math.abs(t - a), c.isOutOfBounds = t < 0 || o < t + n, c.top = t <= e.offset, c.bottom = o <= t + n, c.toleranceExceeded = c.distance > e.tolerance[c.direction], s(c), a = t, i = !1 } function h () { i || (i = !0, n = requestAnimationFrame(l)) } const u = !!o && { passive: !0, capture: !1 }; return t.addEventListener('scroll', h, u), { destroy () { cancelAnimationFrame(n), t.removeEventListener('scroll', h, u) } } } function o (t, n) { n = n || {}, Object.assign(this, o.options, n), this.classes = Object.assign({}, o.options.classes, n.classes), this.elem = t, this.tolerance = (function (t) { return t === Object(t) ? t : { down: t, up: t } }(this.tolerance)), this.initialised = !1, this.frozen = !1 } return o.prototype = { constructor: o, init () { return o.cutsTheMustard && !this.initialised && (this.addClass('initial'), this.initialised = !0, setTimeout(function (t) { t.scrollTracker = n(t.scroller, { offset: t.offset, tolerance: t.tolerance }, t.update.bind(t)) }, 100, this)), this }, destroy () { this.initialised = !1, Object.keys(this.classes).forEach(this.removeClass, this), this.scrollTracker.destroy() }, unpin () { !this.hasClass('pinned') && this.hasClass('unpinned') || (this.addClass('unpinned'), this.removeClass('pinned'), this.onUnpin && this.onUnpin.call(this)) }, pin () { this.hasClass('unpinned') && (this.addClass('pinned'), this.removeClass('unpinned'), this.onPin && this.onPin.call(this)) }, freeze () { this.frozen = !0, this.addClass('frozen') }, unfreeze () { this.frozen = !1, this.removeClass('frozen') }, top () { this.hasClass('top') || (this.addClass('top'), this.removeClass('notTop'), this.onTop && this.onTop.call(this)) }, notTop () { this.hasClass('notTop') || (this.addClass('notTop'), this.removeClass('top'), this.onNotTop && this.onNotTop.call(this)) }, bottom () { this.hasClass('bottom') || (this.addClass('bottom'), this.removeClass('notBottom'), this.onBottom && this.onBottom.call(this)) }, notBottom () { this.hasClass('notBottom') || (this.addClass('notBottom'), this.removeClass('bottom'), this.onNotBottom && this.onNotBottom.call(this)) }, shouldUnpin (t) { return t.direction === 'down' && !t.top && t.toleranceExceeded }, shouldPin (t) { return t.direction === 'up' && t.toleranceExceeded || t.top }, addClass (t) { this.elem.classList.add(this.classes[t]) }, removeClass (t) { this.elem.classList.remove(this.classes[t]) }, hasClass (t) { return this.elem.classList.contains(this.classes[t]) }, update (t) { t.isOutOfBounds || !0 !== this.frozen && (t.top ? this.top() : this.notTop(), t.bottom ? this.bottom() : this.notBottom(), this.shouldUnpin(t) ? this.unpin() : this.shouldPin(t) && this.pin()) } }, o.options = { tolerance: { up: 0, down: 0 }, offset: 0, scroller: t() ? window : null, classes: { frozen: 'headroom--frozen', pinned: 'headroom--pinned', unpinned: 'headroom--unpinned', top: 'headroom--top', notTop: 'headroom--not-top', bottom: 'headroom--bottom', notBottom: 'headroom--not-bottom', initial: 'headroom' } }, o.cutsTheMustard = !!(t() && function () {}.bind && 'classList' in document.documentElement && Object.assign && Object.keys && requestAnimationFrame), o }))
